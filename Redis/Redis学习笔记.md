 Redis是「Remote Dictionary Service」的首字母缩写，也就是「远程字典服务」。
 
#### 1. Redis的基础数据结构
 ```
Redis 有 5 种基础数据结构，分别为：string (字符串)、list (列表)、set (集合)、hash (哈
希) 和 zset (有序集合)。
 ```
####  2. Redis实现延迟队列
```
延迟队列可以通过Redis的ZSET（有序列表来实现），我们将消息序列化成一个字符串作为zset的value，这个消息的到期时间处理为score,
然后用多个线程轮询zset获取到期的任务进行处理。
```
```
Redis 的 zrem 方法是多线程多进程争抢任务的关键，它的返回值决定了当前实例有没有抢到任务，
因为 loop 方法可能会被多个线程、多个进程调用，同一个任务可能会被多个进程线程抢到，通过 zrem 
来决定唯一的属性
```

#### 3. Redis位图是为了解决什么问题？
```
为了简化数据量大的存储空间，redis提供了位图数据结构。
位图不是特殊的数据结构，它的内容其实就是普通的字符串，
也就是byte数组。我们可以使用普通的get/set直接获取和设置整个位图的内容，
也可以使用位图操作getbit/setbit等将byte数组看成[位数组]来处理
```

###### command
```
setbit: setbit x 0 1 // 指定位来写
getbit: getbit w 5   //获取位来读
bitfield(set/get/incrby): 它们都可以对指定位片段进行读写，但是最多只能处理 64 个连续的位，如果
超过 64 位，就得使用多个子指令，bitfield 可以一次执行多个子指令。 

```

#### 4. HyperLogLog 
```
HyperLogLog提供不精确的去重统计计数方案，虽然不精确但是也不是非常不精确，标准误差是0.81%。

HyperLogLog在计数比较
小时，它的存储空间采用稀疏矩阵存储，空间占用很小，仅仅在计数慢慢变大，稀疏矩阵占
用空间渐渐超过了阈值时才会一次性转变成稠密矩阵，才会占用 12k 的空间

1. pf的内存占用为什么是12k？
HyperLogLog实现中使用的是16384个桶，也就是2^14，每个桶的maxbits需要6个bits来存储，最大可以表示maxbits=63，于是总共占用内存就是2^^14 * 6/8 = 12K字节

```
##### command
```
pfadd: 添加用户
pfcount: 计算数量，pfcount具有去重功能
pfmerge: 用于将多个pf计数值累加起来形成一个新的pf值

```
#### 5. 布隆过滤器
```
1. 布隆过滤器是什么？
它可以理解为一个不怎么精确的set结构，当你使用它的contains方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确。只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。

布隆过滤器能准确过滤掉那些已经看过的内容，那些没有看过的内容，它也会过滤掉极少的一部分，但是绝大多数新内容它都能准确识别。这样就完全保证推荐给用户的内容都是无重复的。

布隆过滤器在redis4.0之后出现

2. 布隆过滤器的应用场景
 在爬虫系统中使用布隆过滤器可以大幅降低去重存储消耗
 在NOSQL数据库领域使用，Hbase，cassandra,leveldb,rocksdb内部使用布隆过滤器降低数据库的IO请求数量
 邮箱系统中的垃圾邮件过滤也使用了布隆过滤器。

```

##### command
```
bf.add //添加元素
bf.exists //查询元素是否存在 
bf.madd  //批量添加元素
bf.mexists //批量查询元素是否存在
```
 
#### 6. Redis-Cell
```

```

#### 7. Scan和keys相比有什么特点？
```
相同点:都提供模式匹配功能
1. keys没有offset,limit参数，一次性吐出所有满足条件的key
2.keys是遍历算法，复杂度是O(n)，如果实例中有千万级别以上的key，执行keys会导致redis服务卡顿，所有读写redis的其他指令都会被延后或者延迟报错timeout，因为redis是单线程程序，顺序执行所有指令，其他指令必须等到当前的keys指令执行完了才可以继续
3.scan的复杂度虽然O(n)，但是它是通过游标分布进行的，不会阻塞线程
4.scan提供了limit参数，可以控制每次返回结果的最大条数，limit只是一个hint,返回的结果可多可少
5.服务器不需要为游标保存状态，游标的唯一状态就是scan返回给客户端的游标整数
6.scan返回的结果可能会有重复，需要客户端去重复
7.scan遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的
8.单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为空

```
##### limit是设置多少就会返回多少条么？
```
limit不是限定返回结果的条数，而是限定服务器单次遍历的字典槽位数量。
```
##### scan command
```
redis-cli -h 127.0.0.1 -p 7001 –-bigkeys  //扫描redis中的bigkey
redis-cli -h 127.0.0.1 -p 7001 –-bigkeys -i 0.1 //每隔100条scan指令就会休眠0.1s，不会对redis造成ops，但是扫描的时间会变长
```

#### 8. Redis是个单线程程序？它为什么这么快?
```
1.因为redis所有数据都存在内存中，所有的运算都是内存级别的运算。
```
#### 9. Redis持久化
##### 9.1 Redis快照如何进行持久化？
```
redis使用操作系统的多进程COW(copy on write)机制来实现快照持久化。
```
##### 9.2 AOP原理
###### 1. AOF是什么？
```
AOF日志存贮的是redis服务器的顺序指令序列，AOF日志只记录对内存进行修改的指令记录
```
###### 2.AOF是通过什么来恢复redis当前是咧的内存数据结构的状态?
```
AOF对一个空的redis实例顺序执行所有的指令，也就是重放，来恢复redis当前实例的内存数据结构的状态。
Redis会在收到客户端修改指令后，先进行参数校验，如果没问题，就立即将改指令文本存储到AOF日志中，也就是先存到磁盘，然后再执行指令。这样及时遇到突发宕机，已经存储到AOF日志的指令进行重放一下就可以恢复到宕机前的状态
而redis在长期运行的过程中，AOF的日志会越变越长。如果实例宕机重启，重发整个AOF日志会非常耗时，导致长时间redis无法对外提供服务，所以需要对AOF日志进行瘦身
```
###### 3.AOF是怎样重写的？
```
redis提供了bgrewriteaof指令用于对AOF日志进行瘦身，其原理就是开辟一个子进程对内存进行遍历转换成一系列的redis操作指令，序列化到一个新的AOF日志文件中，序列化完毕后再将操作期间发省的增量AOF日志追加到这个新的AOF日志文件中，追加完毕 后就立刻替代就的AOF日志文件了，瘦身工作就完成了。
```
##### 9.2 Redis4.0 混合持久化
```
重启 Redis 时，我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。我们通常
使用 AOF 日志重放，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实
例很大的情况下，启动需要花费很长的时间。 
Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。将 rdb 文
件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自
持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小

于是在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可
以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。 
```
#### 10. pubsub
##### 什么是消息多播？
```
消息多播就是允许生产者生成一次消息，中间件负责将消息复制到多个消息队列，每个消息队列由相应的消费组进行消费。它是分布式系统常用的一种解耦方式，用于将多个消费组逻辑进行拆分。支持了消息多播，多个消费组的逻辑就可以放到不同的子系统中。
```
##### 什么是PubSub?
```
为了支持消费多播，redis单独使用了一个模块来支持消息多播，也就是PubSub，也就是PublisherSubscriber，发布者订阅者模型。
PubSub缺点:
   PubSub的生产者传递过来一个消息，redis会直接找到相应的消费组传递过来，如果没有消费组，那么消息就会被全部丢掉。如果消费组突然挂掉了，生产者会继续发送消息，挂掉是的消费者在挂掉到重启起来这段时间内生产者发送的消息都会被丢掉。
```

##### 11. 什么是Redis的内存回收机制?
```
如果当前Redis内存有10G，当你删除了1GB的key后，再去观察内存，你会发现内存变化不会太大。原因是操作系统回收内存是以页为单位。如果这个页上只要有一个key还在使用，那么它就不能被回收。Redis虽然删除了1GB的key，但是这些key分散到了很多页面中，每个页面都还有其他的key存在，这就导致了内存不会立即被回收。不过，如果你执行flushdb，然后在观察内存会大仙内存确实被回收了，原因是所有的key都干掉了，大部分之前使用的页面都完全干净了，会立即被操作系统回收，

Redis虽然无法保证立即回收已经删除的key的内存，但是它会重用那写尚未回收的空闲内存，这就好比电影院里虽然人走了，但是座位还在，下一波观众来了，直接坐就行，而操作系统回收内存就好比座位都给搬走了。
```

##### 12. Redis的内存分配算法是什么？
```
Redis为了保持自身结构的简单性，在内存分配这里直接做了甩手掌柜，将内存分配的细节丢给了第三方内存分配库去实现。目前Redis默认了使用了jemalloc。
```

##### 13. Redis主从同步
```
Redis的主从数据是异步同步的，所有分布式的Redis系统并不满足[一致性]要求。客户端在redis的主节点进行数据修改时，立即返回，即使在主从网络连接断开的情况下，主节点依旧可以正常对外提供修改服务，所以Redis它满足了[可用性]。
对于要保持最终一致性的话，从节点会一直努力追赶主节点，最终主从节点的状态会保持一致。就算在网络断开期间，主从节点的数据出现了大量的不一致，一旦网络恢复之后，从节点会采用多种策略努力追赶上落后的数据，最终保持和主节点一致。
```
###### 增量同步
```
增量同步:Redis同步的是指令流。主节点会将那些对自己的状态产生修改性影响的指令记录到自己本地的内存缓存中，然后异步将缓存中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一样的状态，一遍向主节点返回自己的同步偏移量.
 但是因为缓存是有限的，所以redis主库不能将所有的指令都记录在内存缓存中。redis的复制内存缓存是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容。
 但是如果因为网络状况不好，从节点在短时间内无法和主节点进行同步，那么在网络状况恢复之后，redis的主节点中那些没有同步的指令在缓存区中可能已经被后续的指令覆盖掉了，从节点将无法直接通过指令流来进行同步，这个时候就需要用到快照同步了。
```
###### 快照同步

```
快照同步也就是rdb文件进行同步，它是一个非常耗费资源的操作，它数显需要在主库上进行一次bgsave将当前的数据全部快照到磁盘上，然后再将快照文件的内容全部传送到从节点，从节点将快照文件接收完毕之后，会立即进行一次全量加载，加载之前先要将当前的内存数据全部清空，加载完成之后通知主节点继续进行增量同步。
当然，从节点在加载快照文件时，主节点的复制缓存区还是会不停的往前移动，这个时候如果从节点加载快照文件的时间过长而主节点的复制缓存区太小的话，也是导致同步期间的增量指令在复制缓存区中被覆盖，这样就会导致从节点在快照同步完成之后无法进行增量复制，然后又会再次发起快照同步，这样极有可能会陷入快照同步的死循环。
所以[主节点的复制缓存区大小参数要合适，避免快照复制的死循环]

```
###### 无盘复制
```
主节点在进行快照同步时，会进行很重的文件IO操作，特别是对于非SSD磁盘存储时，快照会对系统的负载产生较大影响。[特别是当系统正在进行aof的fsync操作时如果发生快照，fsync将会被推迟执行，这就会严重影响主节点的服务效率。]
Redis2.8.18版开始支持无盘复制，无盘复制指的是主服务器直接通过套接字将快照内容发送到从节点。生成快照是一个遍历的过程。主节点会一边遍历内存，一遍将序列化的内容发送到从节点。从节点还是跟之前一样，先将接收到的内容存储到磁盘文件中，再进行一次性加载。
```

##### 14. 什么是Sentinel模式?
```
Sentinel模式负责监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点切换为主节点。客户端来连接集群时，会首先连接sentinel，通过sentinel来查询主节点的地址，然后再去连接主节点进行数据交互。当主节点发生故障时，客户端会重新向sentinel要地址，sentinel会将最新的主节点地址告诉客户端，应用程序将无需重启即可自动完成节点切换。
```

##### 15. Redis Cluster

```
Cluster是去中心化的，它由多个节点组成，cluster以槽为单位进行划分，提供槽迁移命令。
```

##### 16. Info指令
```
INfo指令统计信息分为9块:
  Server 服务器运行的环境参数
  Clients 客户端相关信息
  Memory 服务器运行内存统计数据
  Persistence 持久化信息
  Stats 通用统计数据
  Replication 主从复制相关信息
  CPU  CPU使用情况
  Cluster 集群信息
  KeySpace 键值对统计数量信息
```

##### Commands
```
// ops_per_sec: operations per second，也就是每秒操作数 
redis-cli info stats |grep ops 
// monitor指令可以快速观察哪些key访问比较频繁，monitor没有限制，会瞬间吐出来巨量的指令文本，所以一般在执行monitor之后立即中断输出
redis-cli monitor 
// 客户端信息
redis-cli info clients 
connected_clients:124  # 这个就是正在连接的客户端数量 
// 查看被拒绝的客户端连接次数
rejected_connections
redis-cli info stats |grep reject 
可以使用client list命令来列出所有的客户端连接地址来确定源头
```

```
redis-cli info memory | grep used | grep human 
used_memory_human:827.46K # 内存分配器 (jemalloc) 从操作系统分配的内存总量
used_memory_rss_human:3.61M  # 操作系统看到的内存占用 ,top 命令看到的内存
used_memory_peak_human:829.41K  # Redis 内存消耗的峰值
used_memory_lua_human:37.00K # lua 脚本引擎占用的内存大小 
```

```
redis-cli info replication |grep backlog repl_backlog_active:0
repl_backlog_size:1048576  # 这个就是积压缓冲区大小
repl_backlog_first_byte_offset:0 
repl_backlog_histlen:0 
```

```
redis-cli info stats | grep sync 
sync_full:0 
sync_partial_ok:0 
sync_partial_err:0  # 半同步失败次数,主从半同步复制失败的次数 
```

