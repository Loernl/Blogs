##### 1. redis的key是如何发现过期了？
```
redis会将每个设置了过期时间的key放入一个独立的字典中，以后会定时遍历这个字典来删除到期的key，除了定时遍历之外，它还会使用惰性策略来删除过期的key，就是在客户端访问这个key的时候，redis会对key的过期时间进行检查，如果过期了就会立即删除，定时删除是集中处理，惰性删除是零散处理
```
##### 2. 什么是redis的定时扫描？它是怎样运行的？
```
redis默认会每秒进行十次过期扫描，过期扫描也不是遍历所有过期字典里面的key，而是采用了一种简单的贪心策略:
1. 从过期字典中随机20个key
2. 删除这20个key中已经过期的key
3. 如果过期的key比率超过1/4，则重复步骤1

```

##### 3. 为什么会进行懒惰删除？
```
执行删除指令del可以直接释放对象的内存，在大部分情况下，这个指令是非常快，没有任何延迟的，不过如果删除的key是一个大对象，比如复杂数据结果，hash类型，那么删除操作就会导致redis在删除那一瞬间进行单线程卡顿。
Redis为了解决这个卡顿的问题，在4.0版本引入了unlink指令，它能对删除操作进行懒处理，丢给后台线程来异步回收内存。
unlink key
如果存在多个线程并发修改数据结构的情况:
  当unlink指令发出时，它就再也无法被主线程中的其他指令访问到了。
```

##### 4. flush是如何清空数据库的？
```
redis提供了flushdb和flushall指令，用来清空数据库，这也是比较慢的操作，而4.0之后同样给这两个指令进行了异步化，在指令后面增加async参数就可以将整棵大树连根拔起，扔给后台线程慢慢燃烧

flushall async
```

###### 5. redis更多异步删除点
```
Redis 回收内存除了 del 指令和 flush 之外，还会存在于在 key 的过期、LRU 淘汰、
rename 指令以及从库全量同步时接受完 rdb 文件后会立即进行的 flush 操作。

```

```
Redis4.0 为这些删除点也带来了异步删除机制，打开这些点需要额外的配置选项。
 1、slave-lazy-flush 从库接受完 rdb 文件后的 flush 操作
 2、lazyfree-lazy-eviction 内存达到 maxmemory 时进行淘汰
 3、lazyfree-lazy-expire key 过期删除
 4、lazyfree-lazy-server-del rename 指令删除 destKey
```

##### 6. redis 指令安全?
```
flushdb和flushdb会让redis的所有数据全部清空，如何避免认为操作失误导致这些灾难性的后果。
redis在配置文件中提供了 rename-command 指令用于将某些危险的指令修改成特别的名称

```